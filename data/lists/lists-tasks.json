[
    {
        "id": "below_zero",
        "signature": "def below_zero(operations: List[int]) -> bool:",
        "docstring": "You're given a list of deposit and withdrawal operations on a bank account that starts with zero balance. Your task is to detect if at any point the balance of account fallls below zero, and at that point function should return True. Otherwise it should return False.",
        "examples": [
            {
                "input": "[1, 2, 3]",
                "output": "False"
            },
            {
                "input": "[1, 2, -4, 5]",
                "output": "True"
            }
        ],
        "difficulty": "Easy"
    },
    {
        "id": "find_closest_elements",
        "signature": "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:",
        "docstring": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each other and return them in order (smaller number, larger number).",
        "examples": [
            {
                "input": "[1.0, 2.0, 3.0, 4.0, 5.0, 2.2]",
                "output": "(2.0, 2.2)"
            },
            {
                "input": "[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]",
                "output": "(2.0, 2.0)"
            }
        ],
        "difficulty": "Medium"
    },
    {
        "id": "search",
        "signature": "def search(lst: List[int]) -> int:",
        "docstring": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than zero, and has a frequency greater than or equal to the value of the integer itself. The frequency of an integer is the number of times it appears in the list. If no such a value exist, return -1.",
        "examples": [
            {
                "input": "[4, 1, 2, 2, 3, 1]",
                "output": "2"
            },
            {
                "input": "[1, 2, 2, 3, 3, 3, 4, 4, 4]",
                "output": "3"
            },
            {
                "input": "[5, 5, 4, 4, 4]",
                "output": "-1"
            }
        ],
        "difficulty": "Medium"
    },
    {
        "id": "triples_sum_to_zero",
        "signature": "def triples_sum_to_zero(l: List[int]) -> bool:",
        "docstring": "triples_sum_to_zero takes a list of integers as an input.\nit returns True if there are three distinct elements in the list that\nsum to zero, and False otherwise.\n\nNote: 'distinct elements' means elements at different indices.",
        "examples": [
            {
                "input": "[1, 3, 5, 0]",
                "output": "False"
            },
            {
                "input": "[1, 3, -2, 1]",
                "output": "True"
            },
            {
                "input": "[1, 2, 3, 7]",
                "output": "False"
            },
            {
                "input": "[2, 4, -5, 3, 9, 7]",
                "output": "True"
            },
            {
                "input": "[1]",
                "output": "False"
            }
        ],
        "difficulty": "Hard"    
    },
    {
        "id": "minPath",
        "signature": "def minPath(grid: List[List[int]], k: int) -> List[int]:",
        "docstring": "Given a grid with N rows and N columns (N >= 2) and a positive integer k, each cell of the grid contains a value. Every integer in the range [1, N * N] inclusive appears exactly once on the cells of the grid.\n\nYou have to find the minimum path of length k in the grid. You can start from any cell, and in each step you can move to any of the neighbor cells, in other words, you can go to cells which share an edge with you current cell.\nPlease note that a path of length k means visiting exactly k cells (not necessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if after making the ordered lists of the values on the cells that A and B go through (let's call them lst_A and lst_B), lst_A is lexicographically less than lst_B, in other words, there exist an integer index i (1 <= i <= k) such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have lst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered list of the values on the cells that the minimum path go through.",
        "examples": [
            {
                "input": "[[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3",
                "output": "[1, 2, 1]"
            },
            {
                "input": "[[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1",
                "output": "[1]"
            }
        ],
        "difficulty": "Hard"    
    }
]